---
layout: article
title: Processes and Threads
author: J_å®‹
tags: OperatingSystem í•œê¸€
mathjax: true
key: operatingSystem02
---



### Process Concepts

- Decomposition : ë³µì¡í•œ ë¬¸ì œë¥¼ ë‹¨ìˆœí•œ ì—¬ëŸ¬ ê°œì˜ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬í•˜ëŠ” ë°©ë²•ë¡ 

#### Process

- Processë€? : 

  - ***Program in execution, or An execution stream in the context of a particular process state***

    - ***Process state*** or ***Context*** : processê°€ ìˆ˜í–‰ë˜ëŠ”ë° ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ” ì •ë³´ë“¤

      :large_blue_diamond: Collection of three types of contexts

      â€‹    \- Memory context

      â€‹        â€¢ Code segment, data segment, <span style="color:red">stack segment</span>, heap

      â€‹    \- Hardware context

      â€‹        â€¢ CPU registers, I/O registers

      â€‹    \- System context

      â€‹        â€¢ Process table, open file table, page table

    - ***Execution stream*** or ***Thread of control*** : processê°€ ì§€ê¸ˆê¹Œì§€ ìˆ˜í–‰í•œ ëª¨ë“  ëª…ë ¹ì–´ë“¤ (ë˜ëŠ” í•¨ìˆ˜ë“¤) ì˜ ìˆœì„œ

      :large_blue_diamond: ***State***ì¤‘ì—ì„œ ìœ ë… <span style="color:red">stack segment</span> ë§Œì€ ***Thread of control***ë¥¼ êµ¬í˜„í•˜ëŠ” structure

      :large_blue_diamond: ì–´ë–¤ Processì˜ execution ìƒí™©ì€ <span style="color:red">stack</span> ì„ í†µí•´ì„œ monitoring í•  ìˆ˜ ìˆë‹¤

      :large_blue_diamond:  <span style="color:red">stack</span> ì€ í•´ë‹¹ Processì˜ ***Run-time Context***ë¼ê³  ì–˜ê¸°í•¨  

- Program == Process ?

  - <span style="color:blue">Program</span> : ì €ì¥ë§¤ì²´ì— ì €ì¥ëœ <span style="color:blue">**å—åŠ¨ì ì¸ (ìŠ¤ìŠ¤ë¡œ ì›€ì§ì´ì§€ ì•Šê³  ë‹¤ë¥¸ ê²ƒì˜ ì‘ìš©ì„ ë°›ì•„ ì›€ì§ì´ëŠ” ê²ƒ )**</span> code sequence
  - <span style="color:green">Process</span> : Program in execution, ì¦‰ <span style="color:green">**èƒ½åŠ¨ì ì¸ (ë‹¤ë¥¸ê²ƒì— ì´ëŒë¦¬ì§€ ì•„ë‹ˆí•˜ê³  ìŠ¤ìŠ¤ë¡œ ì¼ìœ¼í‚¤ê±°ë‚˜ ì›€ì§ì´ëŠ” ê²ƒ)**</span> ì¡´ì¬

#### Multiprogramming & Multiprocessing

- Multiprogramming 
  - Memoryì˜ ê´€ì 
  - Main memoryì— ì—¬ëŸ¬ ê°œì˜ Activeí•œ Processê°€ load ë˜ìˆë‹¤
- Multiprocessing
  - CPUì˜ ê´€ì 
  - CPUê°€ ì—¬ëŸ¬ ê°œì˜ í”„ë¡œì„¸ìŠ¤ì— ì˜í•´ì„œ multiplex ë˜ëŠ” ê²ƒ. í•˜ë‚˜ ìˆ˜í–‰í•˜ë‹¤ê°€ ë‹¤ë¥¸ ê±° ìˆ˜í–‰í•˜ë‹¤ ë‹¤ì‹œ ì˜›ë‚  ê±° ìˆ˜í–‰ë˜ëŠ” ì´ëŸ° ê´€ì ì´ ë©€í‹° í”„ë¡œì„¸ì‹±
- Multiprocessingì€ ë°˜ë“œì‹œ Multiprogramming ì´ì—¬ì•¼ë˜ë‚˜?
  - í˜„ëŒ€ OSì—ì„œëŠ” YES, ì—¬ëŸ¬ ê°œì˜ processê°€ activeí•˜ê²Œ ë„ëŠ”ë°, ê·¸ processê°€ main memoryì— ìˆì–´ì•¼ CPUë¥¼ ë¹¨ë¦¬ ë¹¨ë¦¬ í• ë‹¹ë°›ì„ ìˆ˜ ìˆìŒ
  - ê³¼ê±° OSì—ì„œëŠ” main memoryê°€ ì‘ì•„ì„œ ë¶ˆê°€ëŠ¥í–ˆìŒ, Uni-programming í•˜ë©´ì„œ Multiprocessingì„ í–ˆìŒ
    - Swapping : Memory ë¶€ì¡± ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ CPUë¥¼ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ Processì˜ dataë¥¼ memoryì—ì„œ ë‹¤ë¥¸ ì €ì¥ ì¥ì¹˜ë¡œ ë‚´ë³´ë‚´ê³  CPUë¥¼ ì‚¬ìš©í•  Processì˜ dataë¥¼ memoryë¡œ loadí•˜ëŠ” ê²ƒ

- Processê°€ ì™œ ìœ ìš©í•œì§€?

  - ProcessëŠ” Design-time entityì´ë©° Run-time entityì´ë‹¤.

    - Run-time entity : OSê°€ ê´€ë¦¬í•˜ëŠ” ë‹¨ìœ„ì´ê³  ìˆ˜í–‰ì˜ ì£¼ì²´ì´ê³  CPU,Memory, I/O Deviceë¥¼ í• ë‹¹í•˜ëŠ” ì£¼ì²´ì´ë‹¤

    - Design-time entity : ì‹œìŠ¤í…œì˜ Decompositionì„ í†µí•´ì„œ ë‚˜ì˜¤ëŠ” ê²°ê³¼ë¬¼ë“¤ì„ ë°”ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆê²Œ, ìˆ˜í–‰í•  ìˆ˜ ìˆê²Œ ë§Œë“œëŠ” ì¸¡ë©´ì´ ìˆìŒ

      :warning: ***Task*** : Design-time process (ë³µì¡í•œ Software systemì„  Decompositionì„ í†µí•´ ì„¤ê³„í•˜ê²Œë˜ë©´ ë…ë¦½ì ìœ¼ë¡œ êµ¬í˜„í•  ìˆ˜ ìˆëŠ” entityê°€ ë‚˜ì˜¤ëŠ”ë° ê·¸ê±¸ Taskë¼ê³  ë¶€ë¦„)

- Program = Data Structure + Algorithm
- Processë¥¼  Data Structureë¡œ êµ¬ì¡°í™” ì‹œí‚¤ê¸°
  - OSëŠ” ê° Processì˜ ì •ë³´ë“¤ (Process Control Blockë“¤) ì€ Process Tableì„ í†µí•´ ìœ ì§€í•˜ê³  ê´€ë¦¬í•´ì•¼ë¨
  - Process Table êµ¬í˜„ : Process Control Blockë“¤ì˜ Array 
    - í•œê³„ : OSê°€ ì œê³µí•  ìˆ˜ ìˆëŠ” Process ê°œìˆ˜ê°€ ì œí•œë¨ :arrow_right: Array ëŒ€ì‹  Linked list í˜•íƒœë¡œ êµ¬ì„±í•˜ë©´ë¨

#### State Transition

- ì—¬ê¸°ì„œ StateëŠ” ì–´ë–¤ processê°€ ì§€ê¸ˆ ì–´ë–¤ ìƒí™©ì— ìˆëŠ”ê°€ë¥¼ ë§í•¨

- Process Life Cycle : Processê°€ ìƒì„±ë˜ì—ˆì„ ë•Œ ë¶€í„° ì¢…ë£Œë  ë•Œ ê¹Œì§€ ë°œìƒí•˜ëŠ” ì¼ë ¨ì˜ ìƒíƒœ ë³€í™”

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210813_102816.png" alt="KakaoTalk_20210813_102816" style="zoom:50%;" />

  - *Ready State* : Activeí•œ Processì¸ë° ì•„ì§ CPUë¥¼ ë°›ì§€ ëª»í•´ì„œ ìˆ˜í–‰ì„ ëª»í•˜ê³  ìˆëŠ” ìƒíƒœ (Process nê°œ)
    - Ready Queue : 
      - Ready ìƒíƒœì˜ Processë“¤ì„ ê´€ë¦¬í•˜ê¸° ìœ„í•œ Queueí˜•íƒœì˜ ìë£Œêµ¬ì¡° 
      - ì¼ë°˜ì ìœ¼ë¡œ PCBë“¤ì„ Linked Listë¡œ ì—°ê²°í•˜ì—¬ êµ¬í˜„
  - *Running State* : OSì˜ ê°„íƒì„ ë°›ì•„ì„œ CPUë¥¼ í• ë‹¹ ë°›ì€ ìƒíƒœ  (Process ìµœëŒ€ 1ê°œ)
  - *Waiting State* : ì˜ˆë¥¼ë“¤ì–´ Running Processê°€ ë™ê¸°í™” I/O requestë¥¼ í•˜ì—¬ì„œ ì…ë ¥ë°ì´í„°ê°€ ë“¤ì–´ì˜¬ ë•Œ ê°€ì§€ ê¸°ë‹¤ë ¤ì•¼ë˜ëŠ” ê²½ìš°ì„. ì´í›„ ì›í•˜ëŠ” ì…ë ¥ë°ì´í„°ê°€ ì™”ìœ¼ë©´ Ready Stateë¡œ ê°„ë‹¤ (Process nê°œ)
    - ì´ nê°œì˜ Processë¥¼ ê´€ë¦¬í•˜ê¸° ìœ„í•´ Waiting ì´ìœ (I/O Device)ì— ë”°ë¼ ë³„ë„ì˜ Queueë¥¼ êµ¬í˜„í•¨
  - UNIXì—ëŠ” <a href="#zombieState">Zombie state</a>ë¼ëŠ”ê²Œ ìˆìŒ

- OSê°€ Algorithmicí•˜ê²Œ í•´ì•¼ë˜ëŠ” ì¼ :

  - Processê°€ ìƒì„±ë˜ë©´ PCBë¥¼ í•˜ë‚˜ í• ë‹¹í•˜ê³  ê·¸ Processë¥¼ ì¼ë ¨ì˜ ì¡°ê±´ì— ë”°ë¼ì„œ ë‹¤ë¥¸ Stateë¡œ ì „ì´ì‹œí‚¤ëŠ” ê²ƒ

    

### Process Scheduling

- Process Schedulingì„ í•˜ëŠ” ëª©ì  : ê° Processë“¤ì´ ê³µí‰í•˜ê²Œ CPUë¥¼ ê³µìœ í•  ìˆ˜ ìˆë„ë¡ ë‹¤ìŒì— ìˆ˜í–‰ì‹œì¼œì•¼í•  Processë¥¼ ì„ íƒí•˜ëŠ” ì‘ì—…

- OS Schedulerì˜ ì œì•½ì¡°ê±´ : Fair scheduling , protection(ë‚´ Processê°€ CPUë¥¼ ì‚¬ìš©í•˜ë‹¤ê°€ ë‹¤ë¥¸ Processí•œí…Œ ì–‘ë³´í–ˆì„ ë•Œ ë‚´ í”„ë¡œê·¸ë¨ì— ë¬¸ì œê°€ ìƒê¸°ë©´ ì•ˆë¨)

- OS Schedulerê°€ í•´ì•¼ë˜ëŠ” ì¼ : ì–´ë–¤ ìƒí™©ì´ ë°œìƒí•´ì„œ CPUë¥¼ ë‹¤ë¥¸ Processì—ê²Œ ë„˜ê²¨ì¤˜ì•¼ë  ë•Œ, ì–´ëŠ Processë¥¼ ê³¨ë¼ì•¼ ë˜ëŠ”ê°€

- OS Schedulerë¥¼ êµ¬ì„±í•˜ëŠ” Policyì™€ Mechanism :

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210813_174706.png" alt="KakaoTalk_20210813_174706" style="zoom:50%;" />

  - Policy : ë‹¤ìŒì— ìˆ˜í–‰ë  Processë¥¼ ì„ íƒí•˜ëŠ” ê¸°ì¤€ (Scheduling Policy) -- Fairnessì™€ ì„±ëŠ¥ì— ë§ì€ ì˜í–¥ì„ ì¤Œ

  - Mechanism : CPUë¥¼ í•œ Processì—ì„œ ë‹¤ë¥¸ Processë¡œ ë„˜ê²¨ì£¼ëŠ” ë°©ë²• (Dispatcher)

    - Mechanismì€ Scheduling Policyì™€ëŠ” ë¬´ê´€í•˜ê²Œ ê¸°ê³„ì ìœ¼ë¡œ ëŒì•„ê°€ëŠ” ê²ƒ 

    - OSì˜ ê°€ì¥ ê¹Šìˆ™í•œ ê³³ì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ë¬´í•œ loopë¥¼ ëˆë‹¤ :

      ```c
      while(true){
      	// ì£¼ì–´ì§„ Processë¥¼ ì–´ëŠ ì •ë„ ëŒë¦¼
        // ("ê·¸ Processë¥¼ ê·¸ë§Œ ëŒë ¤ë¼"ë¼ëŠ” ëª…ë ¹ì´ ë‚´ë ¤ì˜¤ë©´) 
        // ê·¸ Processë¥¼ ì¤‘ë‹¨ì„ ì‹œí‚¤ê³  ì¤‘ë‹¨ì‹œí‚¨ Process stateë“¤ì„ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ì €ì¥
        // Policyì— ì˜í•´ ì„ íƒëœ ë‹¤ìŒ Processì˜ stateë“¤ì„ ë¨¼ì € loadí•œ ë‹¤ìŒ ìˆ˜í–‰
      }
      ```

    - **OSì€ ëŠ¥ë™ì ì¸ ì¡´ì¬ì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ì‚¬ì‹¤ <span style="color:blue">ìˆ˜ë™ì ì¸</span> ì¡´ì¬**

      :warning: OSê°€ ëŠ¥ë™ì ì´ë¼ë©´, Dispatcherë§Œ ë„ëŠ” CPUì™€ User processorë¥¼ ë„ëŠ” CPU, CPUê°€ ì´ 2ê°œê°€ ìˆì–´ì•¼ ëœë‹¤. ê·¼ë° OSëŠ” Single processorì—ì„œë„ ì˜ ëˆë‹¤

      :warning:  **OSëŠ” Kernel Modeì—ì„œ ìˆ˜í–‰ë˜ëŠ” Library(í•¨ìˆ˜ë“¤ì˜ Collection) ì´ë‹¤** 

      â€‹	:small_red_triangle: ê° í•¨ìˆ˜ë“¤ì„ "**System call í•¨ìˆ˜**"ë¼ê³  í•¨

      â€‹	:small_red_triangle: Kernel Function : System callë¥¼ êµ¬í˜„í•œ í•¨ìˆ˜ë“¤ + Interrupt Service Routine(ISR)

      â€‹	:small_red_triangle: Dispatcher ë„ Kernel Functionì¤‘ í•˜ë‚˜ì„

      â€‹	<img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210813_201527.png" alt="KakaoTalk_20210813_201527" style="zoom:43%;" />

    - ì–´ë–»ê²Œ í•˜ë©´ Single processorë¡œ Dispatcherì™€ User processorë¥¼ ëª¨ë‘ ëŒë¦´ ìˆ˜ ìˆì„ ê¹Œ?

      :small_blue_diamond: User processorê°€ ìš´í•´ë˜ë‹¤ ì¤‘ë‹¨ (User Mode) :arrow_right: Dispatcher code ìš´í–‰ (Kernel Mode) :arrow_right: ë‹¤ë¥¸ User processorê°€ ìš´í–‰ (User Mode)  :arrow_right:  ...

      :small_blue_diamond: ì¦‰, User Modeì—ì„œ Kernel Modeë¡œ ì „í™˜í•˜ê¸° ìœ„í•œ í•˜ë“œì›¨ì–´ì ì¸ Interruptê°€ í•„ìš”í•˜ë‹¤ 

      :small_blue_diamond: DispatcherëŠ” User programê³¼ User programê°€ ìˆ˜í–‰ë˜ëŠ” ì¤‘ê°„ì— ê°œì…í•´ì„œ CPUë¥¼ process Aì—ì„œ process Bë¡œ ë„˜ê²¨ì£¼ëŠ” ì—­í• ì„ í•œë‹¤ 

    - Processorê°€ Kernel modeì™€ User modeë¥¼ êµ¬ë¶„í•˜ëŠ” ë°©ì‹ :

      :small_blue_diamond: PSW(Process Status Word) Registerì•ˆì˜ íŠ¹ì • bitë¥¼ Mode bitë¡œ ì‚¬ìš©

      â€‹	<img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-08-30 at 5.36.25 PM.png" alt="Screen Shot 2021-08-30 at 5.36.25 PM" style="zoom:40%;" />

    - Dispatcherë¥¼ í˜¸ì¶œí•˜ëŠ” ë°©ë²•

      1. Non-preemptive Scheduling 

         - Processê°€ ìë°œì ìœ¼ë¡œ CPUë¥¼ ì–‘ë³´í•˜ì—¬ ë‹¤ë¥¸ Processë¥¼ ìˆ˜í–‰í•˜ëŠ” Scheduling 

         (Ex. ì§€ê¸ˆ CPUì—ì„œ ëŒê³  ìˆëŠ” Processê°€ I/O ìš”ì²­ì„ í–ˆëŠ”ë° ì•„ì§  I/Oê°€ ì¤€ë¹„ë˜ì§€ ì•Šì„ ê²½ìš°)

         - êµ¬í˜„ ë°©ë²• : ***Software Interrupt*** (Trap)ì„ ì‚¬ìš©í•˜ë©´ ì´ Scheduling ì„ í˜¸ì¶œ í•  ìˆ˜ ìˆìŒ

      2. Preemptive Scheduling <a name="Preemptive"></a>

         - OSê°€ ê°•ì œë¡œ Processë¡œ ë¶€í„° CPUë¥¼ ë¹¼ì•—ì•„ ë‹¤ë¥¸ Processë¥¼ ìˆ˜í–‰í•˜ëŠ” Scheduling 

         (Ex. CPUê°€ Time sharingì„ í•  ê²½ìš°)

         - êµ¬í˜„ ë°©ë²• : Timer ***Hardwareì˜ interrupt***ì— ì˜í•´ì„œ ì´ Scheduling ì´ ì´‰ë°œì´ ë¨ 

    - Mode change of process

        <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210813_201558.png" alt="KakaoTalk_20210813_201558" style="zoom:53%;" />

      :small_red_triangle: Kernel Mode Executionì´ ì¼ì–´ë‚  ë•Œ ìˆ˜í–‰ì˜ ì£¼ì²´ê°€ ë˜ëŠ” ProcessëŠ”? : 

      System Callì„ í˜¸ì¶œí•œ ì‚¬ìš©ì process (ì¦‰, í˜„ì¬ ìˆ˜í–‰ì¤‘ì¸ Process IDëŠ” ë˜‘ê°™ì€ ë†ˆì´ë‹¤)

      :small_red_triangle: Processê°€ User Modeì—ì„œ ìˆ˜í–‰ ë  ë•ŒëŠ” User mode stackì„ ì‚¬ìš©í•˜ê³ , Kernel modeì—ì„œ ìˆ˜í–‰ë  ë•ŒëŠ” Kernel mode stackì„ ì‚¬ìš©í•œë‹¤.

      :small_red_triangle: System callê³¼ ì¼ë°˜ function callì˜ ì°¨ì´ :

      í•œ ë£¨í‹´ì—ì„œ ë‹¤ë¥¸ ë£¨í‹´ìœ¼ë¡œ ë„˜ì–´ê°„ë‹¤ëŠ” ì ì€ ê°™ì§€ë§Œ function callì€ Mode changeê°€ ë°œìƒí•˜ì§€ :x: , System callì€ User modeì—ì„œ Kernel modeë¡œ Mode changeê°€ ë°œìƒí•œë‹¤

      

### Context Switching

- **Context Switching** : Dispatcherê°€ í•´ì•¼ë˜ëŠ” ì—­í• . ì¦‰, **í˜„ì¬ ìˆ˜í–‰ì¤‘ì¸ Processì˜ stateë¥¼ ì €ì¥í•˜ê³  ë‹¤ìŒ ìˆ˜í–‰ë  processì˜ stateë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì‘ì—…**

- Context saving : ì§€ê¸ˆ ì¤‘ë‹¨ëœ processì˜ stateë“¤ì„ ì•ˆì „í•œ ê³³ìœ¼ë¡œ ëŒ€í”¼ì‹œí‚¤ëŠ” ë™ì‘

  - Memory, Hardware, System contextì´ 3ê°€ì§€ stateì¤‘ì— ì–´ë–¤ ê±¸ ì„ íƒí•´ì„œ  ëŒ€í”¼ì‹œì¼œì•¼ì§€?

    *Option 1* : ì „í˜€ ëŒ€í”¼ ì‹œí‚¤ì•ŠëŠ”ë‹¤

    â€‹	:small_blue_diamond: ê³¼ê±°ì— Multiprogrammed batch monitor ì‹œì ˆ

    *Option 2* : Roll-in/Roll-out swapping (ëª½ë•… ë‹¤ Diskì— ëŒ€í”¼ì‹œí‚¨ë‹¤)

    â€‹	:small_blue_diamond: Uni-programmingì„ í•  ë•Œ í•„ìš” : Main memoryì— í•˜ë‚˜ì˜ processë§Œ ì˜¬ë ¤ë†“ê³  ìˆ˜í–‰ì‹œí‚¤ë‹¤ê°€ ê²Œê°€ CPUë¥¼ ë¹¼ì•—ê¸°ê²Œë˜ë©´ ì´ processsëŠ” Diskë¡œ ë‚˜ê°€ê³  Diskì— ìˆë˜ ìƒˆë¡œìš´ processê°€ Main memoryë¡œ ë“¤ì–´ì˜´ (ì´ë•ŒëŠ” ë©”ëª¨ë¦¬ê°’ì´ ë¹„ì‹¸ì„œ ì—¬ëŸ¬ í”„ë¡œê·¸ë¨ì„ ì˜¬ë¦´ ìˆ˜ ê°€ ì—†ì—ˆìŒ)

    â€‹	:small_blue_diamond: ë‹¨ì  : êµ‰ì¥íˆ ëŠë¦¼

    *Option 3* : Swapping (í˜„ì¬ ì‚¬ìš©ë˜ëŠ” ì¼ë¶€ë§Œ Diskë¡œ ëŒ€í”¼ì‹œí‚¨ë‹¤)

    â€‹	:small_blue_diamond: ë©”ëª¨ë¦¬ ì•ˆì— ë„ˆë¬´ ë§ì€ activeí•œ í”„ë¡œì„¸ìŠ¤ê°€ ë“¤ì–´ ìˆì–´ ìˆì„ ë•Œ ì–´ì©” ìˆ˜ ì—†ì´ ë©”ëª¨ë¦¬ ê³µê°„ì„ ë¹„ìš°ê¸° ìœ„í•´ ì„ íƒëœ ì¼ë¶€ë§Œ Diskë¡œ ë³´ëƒ„. (Swap out)

    â€‹	:small_blue_diamond:ëŒ€ë¶€ë¶„ ëª¨ë“  OSì—ì„œëŠ” Swap out ê¸°ë²•ì„ ì‚¬ìš©í•˜ê³  ìˆìŒ

    :red_circle: ê²°êµ­ : Hardware contextëŠ” ë°˜ë“œì‹œ ëŒ€í”¼, Memory contextëŠ” í•„ìš”í•œ ê²½ìš° ë¶€ë¶„ì ìœ¼ë¡œ ëŒ€í”¼, System contextëŠ” ê·¸ëƒ¥ ë‚´ë¹„ë‘ë©´ ëœë‹¤

    :question: (Hardware context ì¤‘ í•˜ë‚˜ì¸) CPU RegisterëŠ” Diskë¡œ ëŒ€í”¼ ì‹œí‚¤ëŠ” ê²ƒì¸ê°€?

    â€‹	 <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/ap01fig05.gif" alt="ap01fig05" style="zoom:63%;" />

    â€‹	ğŸ’ğŸ» ì¼ë°˜ì ìœ¼ë¡œ memory hierarchyì˜ í•œ ë‹¨ê³„ ì•„ë˜ì˜ ì €ì¥ ì¥ì¹˜ë¡œ ë°ì´í„°ë¥¼ ëŒ€í”¼ì‹œí‚¤ê¸° ë•Œë¬¸ì— CPU RegisterëŠ” Main memoryë¡œ ëŒ€í”¼ì‹œí‚¨ë‹¤ (CacheëŠ” ì†ì„±ì´ ë‹¤ë¥¸ ë©”ëª¨ë¦¬ë‹ˆê¹ ê±°ê¸°ë‹¤ ëŒ€í”¼ì‹œí‚¤ë©´ ì•ˆë¨). ì´ ë¶€ë¶„ì€ ë‹¤ìŒ Context Switchingì˜ Mechanismì„ í†µí•´ í™•ì¸ í•  ìˆ˜ ìˆë‹¤

- Context Switchingì˜ ë°°ê²½

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-08-31 at 6.29.52 PM.png" alt="Screen Shot 2021-08-31 at 6.29.52 PM" style="zoom:43%;" />

  **[1]** **User process ëª…ë ¹ì„ ì‹¤í–‰í•˜ëŠ” ì¤‘ì— Interrupt ë°œìƒ** 

  1. MicroprocessorëŠ” ì§€ê¸ˆ ìˆ˜í–‰ì¤‘ì¸ ëª…ë ¹ì„ ìš°ì„  ëì„ ë‚¸ë‹¤
  2. Interrupt Checkingì„ í•œë‹¤ 

  **[2]** **Interrupt ìˆ˜í–‰**

  1. MicroprocessorëŠ” Interruptì˜ IRQ Numberë¥¼ í™•ì¸ 
  2. IRQ Numberì— ë”°ë¼ Interrupt Vector tableì„ ë’¤ì ¸ì„œ í•´ë‹¹ Interrupt service routineì˜ ì‹œì‘ ì£¼ì†Œ í™•ì¸
  3. Interrupt service routineì˜ ì‹œì‘ ì£¼ì†Œë¡œ Jump
  4. Interrupt service routine ìˆ˜í–‰

  **[3]** **ë‹¤ì‹œ User processë¡œ ë³µê·€**

  

- Context Switchingì˜ Mechanism 

  - Terms :
    - OSPCBCur : í˜„ì¬ ìˆ˜í–‰ë˜ê³  ìˆëŠ” Processì˜ PCBë¥¼ ê°€ë¥´í‚¤ëŠ” Global variable
    - PCBì— ìˆëŠ” ë‚´ìš©ë“¤ : Process ID, Stack pointer field (StkPtr), ë“±ë“± ...
    - CPU Stack pointer register : í˜„ì¬ stackì˜ ìµœìƒë‹¨ ì£¼ì†Œë¥¼ ì €ì¥í•˜ê³  ìˆìŒ

  - Mechanism :

    1. Interruptê°€ ê±¸ë¦¬ë©´ Hardwareì ìœ¼ë¡œ stackì— PSWê°’ê³¼ PCê°’ì´ ì €ì¥ë¨ 

         <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-08-31 at 11.59.08 PM.png" alt="Screen Shot 2021-08-31 at 11.59.08 PM" style="zoom:25%;" />

    2.  Interrupt service routineìœ¼ë¡œ Jump

    3. PUSHALL ëª…ë ¹ì‹¤í–‰ : CPU Register ê°’ë“¤ì„ ì „ë¶€ stackì— ëŒ€í”¼ 

       ( **[2]**.4 Interrupt service routine ìˆ˜í–‰ë  ë•Œ ê°€ì¥ ë¨¼ì € í•´ì•¼ë˜ëŠ” ê²ƒ )

        <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 12.09.18 AM.png" alt="Screen Shot 2021-09-01 at 12.09.18 AM" style="zoom:25%;" />

    4. ì§€ê¸ˆ ì¤‘ë‹¨ëœ processì˜ Context saving ì™„ë£Œ

    5. CPUì˜ Stack pointer register ê°’ì„ PCBì˜ Stack pointer field (StkPtr)ì—ë‹¤ ì €ì¥

         <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 12.18.43 AM.png" alt="Screen Shot 2021-09-01 at 12.18.43 AM" style="zoom:25%;" />

    6. ë‹¤ìŒì— ì‹¤í–‰ë˜ì•¼ë˜ëŠ” processì˜ PCB pointerë¥¼ OSPCBCur ë³€ìˆ˜ì— ê¸°ë¡

         <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 12.26.55 AM.png" alt="Screen Shot 2021-09-01 at 12.26.55 AM" style="zoom:25%;" />

    7. ìƒˆë¡œìš´ PCBì˜ Stack pointer field (StkPtr)ë¥¼ CPUì˜ Stack pointer registerì—ë‹¤ ì €ì¥ 

         <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 12.29.06 AM.png" alt="Screen Shot 2021-09-01 at 12.29.06 AM" style="zoom:25%;" />

    8. POPALL ëª…ë ¹ì‹¤í–‰ : ìƒˆë¡œ ìˆ˜í–‰ë  Processì˜ contextë“¤ì´ CPU registerë¡œ ë“¤ì–´ì˜¤ê²Œ ë¨

         <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 12.34.33 AM.png" alt="Screen Shot 2021-09-01 at 12.34.33 AM" style="zoom:25%;" />

    9. PCì™€ PSWë¥¼ POPí•¨ : ìƒˆë¡œ ìˆ˜í–‰ë  Processì˜ PC ì£¼ì†Œë¡œ jump, PSWì˜ Mode bitì— ë”°ë¼ mode change

  â“ PSWëŠ” stackì— ì™œ ë“¤ì–´ê°€ì•¼ë˜ë‚˜? 

  â€‹	ğŸ’ğŸ» interruptê°€ ëë‚˜ê³  ë‹¤ì‹œ User processë¡œ ë³µê·€í•˜ë©´ ì´ processë¥¼ ì‹¤í–‰ ì‹œí‚¤ìœ„í•œ modeë¡œ ë‹¤ì‹œ íšŒë³µ ì‹œí‚¬ í•„ìš”ê°€ ìˆìœ¼ë‹ˆê¹

  â“Hardwareê°€ ì§ì ‘ PSW ê·¸ë¦¬ê³  PC ê°’ì„ stackì— ë„£ì–´ì£¼ê³  PUSHALL ëª…ë ¹ì˜ ë™ì‘ê¹Œì§€ í•´ì£¼ë©´ ì•ˆë¨?

  â€‹	ğŸ’ğŸ» í”„ë¡œê·¸ë˜ë° ìƒí™©ì— ë”°ë¼ ì¼ë¶€ RegisterëŠ” ëŒ€í”¼í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ìƒí™©ì´ ë°œìƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— PUSHALL ëª…ë ¹ì€ Softwareì ìœ¼ë¡œ êµ¬í˜„í•œë‹¤

- ì´ MechanismëŠ” ì˜ ë™ì‘í•˜ëŠ”ë° ë”± í•˜ë‚˜ ì˜ˆì™¸ê°€ ìˆë‹¤ :

  - ProcessëŠ” ì ì–´ë„ í•œë²ˆì€ Context switchingì„ ë‹¹í•´ì•¼ë¨. ê·¸ë˜ì•¼ë§Œ ìê¸°ì˜ Stackì´ êµ¬ì„±ì´ ë  ìˆ˜ ìˆìŒ

  - ì˜ˆì™¸ì˜ ê²½ìš°ëŠ” ì²˜ìŒ Processê°€ ë§Œë“¤ì–´ ì¡Œì„ ë•Œ ì´ë‹¤.

    - ì´ë•ŒëŠ” OSì´ ì–´ë–¤ Processë¥¼ ìƒì„±í•˜ê²Œ ë˜ë©´ ê·¸ processì˜ stackì„ ë§ˆì¹˜ Context switchingì„ í•œë²ˆì´ë¼ë„ ë‹¹í•œê²ƒ ì²˜ëŸ¼  Fake stackì„ ë§Œë“¤ì–´ ì¤€ë‹¤

        <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210818_123025.png" alt="KakaoTalk_20210818_123025" style="zoom:75%;" />

:warning: Main memoryì—ëŠ” ê° Process ë³„ë¡œ Stackì„ ê°€ì§€ê³  ìˆê³  ë‹¨ì§€ Activeí•œ Stackì€ í˜„ì¬ 1ê°œê°€ ìˆë‹¤ëŠ” ì‚¬ì‹¤ ìŠì§€ë§ê¸°

- ìš”ì•½ : 
  - OS SchedulerëŠ” Policy ë¶€ë¶„ê³¼ ê³µí†µì ì¸ Mechanismë¶€ë¶„ì´ ìˆë‹¤.
  - ì—¬ê¸°ì„œ Mechanismë¶€ë¶„ì´ Context Switchingì„ ë‹´ë‹¹í•˜ëŠ” Dispatcherë‹¤
  - Dispatcherê°€ ìˆ˜í–‰ë ë ¤ë©´, User processì™€ User processì‚¬ì´ì— mode change ê°€ ì¼ì–´ë‚˜ì„œ ìˆ˜í–‰ì´ ë˜ì•¼ëœë‹¤



### Process Creation and Termination

#### Process Creation

- UNIXê³„ì—´ OSëŠ” Bootingí•  ë•Œ  ***ë”± í•œë²ˆ*** 0ë²ˆ Processë¥¼ ìƒì„±í•  ë•Œ, ë‹¤ìŒê³¼ ê°™ì€ ê³¼ì •ìœ¼ë¡œ ìƒì„±ì„ í•œë‹¤
  - 0ë²ˆ Process Creation ê³¼ì • :

    **[1]** Program Loading

    1. File systemì— executable fileì´ ìˆìŒ 
    2. executable fileì˜ path nameì´ OSì— ì „ë‹¬
    3. OSëŠ” executable fileì˜ codeë“¤ì„ Memory contextì˜ í•œ ë¶€ë¶„ì¸ code segmentì— ì½ì–´ë“œë¦¼
    4. executable fileì˜ Global ë³€ìˆ˜ë“¤ì— ëŒ€í•œ ì„ ì–¸ê³¼ ì •ë³´ë“¤ì„ data segmentì— ì˜ì—­ì„ ë‹¤ ì¡ì•„ì¤Œ

    **[2]** Stack segment, heap ë¥¼ ìƒì„±

    **[3]** Pocessì˜ PCBë¥¼ ìƒì„± 

    **[4]** PCBì„ Ready Queueì—ë‹¤ ë„£ê¸°



- 0ë²ˆ Processì™¸ì˜ ë‚˜ë¨¸ì§€ Processë“¤ì€ ë³µì œë¼ëŠ” ê¸°ë²•ì„ ì‚¬ìš©í•´ì„œ ìƒì„±í•œë‹¤
  - ***Parent Process*** : Process Cloningì„ ì´ˆë˜í•˜ëŠ” ê¸°ì¡´ì˜ Process

  - ***Child Process*** : Parent Processë¡œë¶€í„° ë§Œë“¤ì–´ì§€ëŠ” ìƒˆë¡œìš´ Process

  - ë‚˜ë¨¸ì§€ Processë“¤ì˜ Creation ê³¼ì • : 

    1. Parent Processê°€ Child Processë¥¼ ë§Œë“¤ê¸° ìœ„í•´ì„  `fork()` ë¼ëŠ” System Callì„ í˜¸ì¶œí•¨

    2.  `fork()` ë¥¼ í˜¸ì¶œì´ ë˜ë©´, OSê°€ Parent Processì˜ ìˆ˜í–‰ì„ ì¤‘ë‹¨ ì‹œí‚´, Parent Processì˜ Contextë¥¼ ê·¸ëŒ€ë¡œ copy í•´ì„œ Child Processë¥¼ ìƒì„± ( ë‹¨, PCBì˜ ProcessIDëŠ” ë‹¤ë¥¸ê°’ì„ ê°€ì§ )

    3. Child Processì˜ PCBë¥¼ Ready Queueë¡œ ë³´ëƒ„

    4.  `fork()` System Call ìˆ˜í–‰ ë

    5. Parent Processë¡œ return

  -  `fork()` System Call (Cloning ë°©ì‹ìœ¼ë¡œ Child Process ìƒì„±)ì˜  ë¬¸ì œì  :
    - ë§¨ ì²˜ìŒ ë§Œë“  Process 0 í”„ë¡œê·¸ë¨ ì™¸ ì—ëŠ” ë‹¤ë¥¸ í”„ë¡œê·¸ë¨ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ë‹¤
    
  - ê·¸ë˜ì„œ  `fork()` í•œ ë‹¤ìŒì— `exec(..)` System Callì„ í˜¸ì¶œì‹œí‚´
  
    - `exec(...)` : ìƒì„±ëœ í”„ë¡œê·¸ë¨ì˜ executable file path nameì„ parameterë¡œ ë°›ì•„ì„œ executable fileì˜ codeì™€ dataë¥¼ ì½ì–´ì™€ì„œ Parentì˜ ë‚´ìš©ì„ override í•œë‹¤
  
- Process life cycle in UNIX :

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/KakaoTalk_20210819_101320.png" alt="KakaoTalk_20210819_101320" style="zoom:60%;" />

  -  `fork()` ìˆ˜í–‰ å : Child ProcessëŠ” Parent Processì˜ contextë¥¼ copy
  -  `exec(...)` ìˆ˜í–‰ å : Child Processê³¼ Parent Processê°€ ë‹¤ë¥¸ programì„ ìˆ˜í–‰í•˜ëŠ” Processê°€ ë¨
  -  `exit()` : 
    - Processë¥¼ ì¢…ë£Œì‹œí‚¤ëŠ” System Call 
    - OSê°€ ì•Œì•„ì„œ `exit()` Callì„ í•´ì¤Œ
    - ê·¸ Processê°€ ê°€ì§€ê³  ìˆë˜ Data structure, Resourceë¥¼ OSê°€ ê±·ì–´ê°
    -  `exit()` Call ìˆ˜í–‰ì´ ì˜ë¬ë‚˜ ì˜ì•ˆë¬ë‚˜ë¥¼ í‘œí˜„í•˜ëŠ” ê²°ê³¼ codeë¥¼ í•˜ë‚˜ ë‚¨ê¹€
    - ê·¸ code ê°’ì„ `wait(...)` í•˜ê³  ìˆëŠ” processì—ê²Œ ì „ë‹¬í•˜ê²Œ ë¨
    - Parent ProcessëŠ” ê·¸ë•Œì„œì•¼ ê¹¨ì–´ë‚˜ì„œ ìê¸° ë‚˜ë¨¸ì§€ ìˆ˜í–‰ì„ í•¨ 
    - Zombie state<a name="zombieState"></a> :  `exit()` ë¥¼  ë§ˆì¹˜ê³  Parent Processê°€ ìì‹ ì˜ Exit statusë¥¼ ì½ì–´ê°€ê¸°ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” Processì˜ ìƒíƒœ
  - `wait(...)` : 
    - ìê¸°ê°€ ìƒì„±í•œ Child processì˜ idë¥¼ parameterë¡œ ë„˜ê²¨ì¤Œ
    - parameterë¡œ ë°›ì€ processê°€ ìˆ˜í–‰ì„ ì¢…ë£Œí•  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¬ê²Œ í•˜ë¼ëŠ” System Call

- Shell code Example :

  - Shell : ì‚¬ìš©ìê°€ ì…ë ¥í•œ ëª…ë ¹ì–´ë¥¼ ì…ë ¥ìœ¼ë¡œ ë°›ì•„ë“¤ì—¬ ìƒˆë¡œìš´ Processë¥¼ ìˆ˜í–‰ì‹œí‚¤ëŠ” Program
  - System callë“¤ì˜ return ê°’ë“¤ :
    - ìŒìˆ˜ : System Error
    - 0ì´ìƒì˜ ì–‘ìˆ˜ : ì œëŒ€ë¡œ ë™ì‘ 

  ```shell
  for(;;) {
      cmd = readcmd(); // ì‚¬ìš©ìì˜ ëª…ë ¹ì–´ë¥¼ ë°›ìŒ
      pid = fork();    // ì‚¬ìš©ìì˜ ëª…ë ¹ì„ ìˆ˜í–‰ì‹œí‚¬ Child Processë¥¼ ë§Œë“¬
      if (pid < 0) {	 // ë§Œì•½ System Errorì¼ ê²½ìš°, ì¢…ë£Œ
          perror("fork failed");
          exit(-1);
      } 
      else if (pid == 0) { 
      		// Child Processê°€ ìˆ˜í–‰ë˜ëŠ” ë¶€ë¶„
          // Child â€“ Setup environment
          if(exec(cmd) < 0) perror("exec failed");
          exit(-1); // Exit on exec failure
      } 
      else { 
      		// ë§Œì•½ Child Processì˜ idê°€ 0ë³´ë‹¤ í´ ê²½ìš°,
      		// Child Processì˜ ì‹¤í–‰ì´ ëë‚  ë•Œ ê¹Œì§€ Parent processëŠ” Waití•œë‹¤
          // Parent â€“ Wait for command to finish
          wait(pid);
      }
  }
  ```

  - `pid = fork(); `  : 
    - ì´ë•Œ Child processê°€ Parent processë¡œë¶€í„° ë³µì œë¬ê¸° ë•Œë¬¸ì— Child processì˜ ëª…ë ¹ ì‹¤í–‰ ì‹œì‘ ì£¼ì†ŒëŠ” Parent processì™€ ë˜‘ê°™ì€  `pid = fork(); `  ì˜ ë°”ë¡œ ë‹¤ìŒ ëª…ë ¹ì˜ ì£¼ì†Œê°€ ëœë‹¤
    - í•˜ì§€ë§Œ ì´ë•Œ  System call return valueë¥¼ Child processí•œí…ŒëŠ” 0ìœ¼ë¡œ Parent processí•œí…ŒëŠ” Child processì˜ pidë¥¼ ë„£ìŒ (:warning: æ³¨æ„ ï¼š Child processì˜ idë¥¼ 0ìœ¼ë¡œ ì£¼ëŠ”ê²Œ ì•„ë‹ˆë¼ `fork()` System callì˜ returnê°’ì´ 0ì´ë‹¤ )

-   `fork()` ë¥¼ í†µí•´ Process ìƒì„±í•˜ëŠ” ë°©ì‹ì˜ ì„±ëŠ¥ ë¬¸ì œ í•´ê²° ë°©ì•ˆ : 

  - ì„±ëŠ¥ ë¬¸ì œ : 
    - Parentì˜ Codeì™€ Dataë¥¼ ë³µì‚¬í–ˆëŠ”ë° ë°”ë¡œ `exec(...)` ìœ¼ë¡œ overrideë˜ëŠ” ë¬¸ì œ
    - ì¦‰, ë¶ˆí•„ìš”í•œ copyë¥¼ í†µí•œ ì„±ëŠ¥ ì €í•˜
  - í•´ê²° ë°©ì•ˆ : ***Copy on Write(COW)*** 
    -  `fork()` ì‹œì ì— Process Contextë¥¼ ë³µì‚¬í•˜ì§€ ì•Šê³  pointer Data structureë¥¼ ë§Œë“¤ì–´ì„œ parentì˜ codeì™€ data segmentë¥¼ childê°€ pointí•˜ê²Œ ë§Œë“¬(ëŒ€ì‹  stack segmentëŠ” ë³„ë„ë¡œ ê°€ì§€ê³  ìˆê³ ), ê·¸ë¦¬ê³  Data Segmentì— ìƒˆë¡œìš´ ê°’ì´ ì“°ì—¬ì§ˆ ë•Œ ë³µì‚¬í•˜ëŠ” ê¸°ë²•

#### Process Termination

- Process Terminate ë°©ë²•ë“¤ 
  1. `exit(); ` : Process executes last statement and asks the OS to decide it 
  2. `abort();` : Parent may terminate execution of children processes



### Multithreading

#### Multithreadingì˜ ëª©ì  

1. ConcurrencyëŠ” ë†’ì´ë©´ì„œ 
2. Execution Unitì„ ìƒì„±í•˜ê±°ë‚˜ ìˆ˜í–‰ì‹œí‚¤ëŠ”ë° ë“œëŠ” ë¶€ë‹´ì„ ì¤„ì„

- Processê°€ ìƒì„±ë ë ¤ë©´ Contextê°€ ìƒì„±ë˜ì•¼ë˜ê³ , ê·¸ ì™¸ì— Logical addressë¥¼ Physical addressë¡œ Mappingì‹œí‚¤ìœ„í•œ mapping tableë“¤ ê·¸ë¦¬ê³  ë§ì€ ë¶€ìˆ˜ì ì¸ ì •ë³´ë“¤ì´ í•„ìš”í•˜ê²Œ ë¨. ê·¸ë˜ì„œ ìˆ˜ë§Œê°œì˜ processê°€ í•œ Systemì— ê³µì¡´í•˜ê²Œ ë˜ë©´ Systemì„ ìš´ìš©í•˜ê¸° ì–´ë ¤ìš¸ ì •ë„ì— ì„±ëŠ¥ì €í•˜ê°€ ì¼ì–´ë‚˜ê²Œ ë¨

- Multithreadingí•˜ê²Œ ë˜ë©´ Single threadingì˜ Processì™€ ë‹¬ë¼ì§„ ì  :

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-01 at 6.06.13 PM.png" alt="Screen Shot 2021-09-01 at 6.06.13 PM" style="zoom:25%;" />

  - Thread = Execution stream ë˜ëŠ” Stack
    - ê·¸ë¦¼ì—ì„œ User stackì€ user modeì—ì„œ ì‚¬ìš©ë˜ëŠ” stack ê·¸ë¦¬ê³  Kernel stackì€ kernel modeì—ì„œ ì‚¬ìš©ë˜ëŠ” stackì„ ë‚˜íƒ€ë‚´ê³  ìˆë‹¤
  - Single Threading : a.k.a Conventional UNIX Process<a name="CUP"></a>
  - í•˜ë‚˜ì˜ Processê°€ ì—¬ëŸ¬ ê°œì˜ Thread(ì—¬ëŸ¬ ê°œì˜ Execution stream ë˜ëŠ” Stack)ë¥¼ ê°‡ê²Œë¨
  - ì—¬ëŸ¬ ê°œì˜ Threadë“¤ì€ ê·¸ Processì— ë¶€ì—¬ëœ Address spaceì™€ resourceë“¤ì„ ê³µìœ í•œë‹¤

- Threadì˜ êµ¬í˜„ì„ ìœ„í•´ í•„ìš”í•œ ìë£Œêµ¬ì¡°

  - Stack 
  - Thread ID : ê° Threadë“¤ì˜ naming
  - Thread Control Block (TCB) : ê° Thread IDì— ì†Œì†ëœ ì •ë³´ë¥¼ ë‹´ìŒ

- ì—¬ëŸ¬ ê°€ì§€ OSì—ì„œ Multithreadingì˜ ì§€ì› 

  - *MS-DOS* : Single Tasking Kernel - í•˜ë‚˜ì˜ Process ì§€ì›, ê·¸ ì•ˆì— í•˜ë‚˜ì˜ Thread of Controlë§Œ ì§€ì›
  - *ê³¼ê±° UNIX* : Multi Taking Kernel - ì—¬ëŸ¬ê°œì˜ Process ì§€ì›, ê°ê° Processë“¤ ì•ˆì— í•˜ë‚˜ì˜ Thread of Control ë°–ì— ê°€ì§ˆ ìˆ˜ ë°–ì— ì—†ì—ˆìŒ
  - *ìµœê·¼ OS* : ì—¬ëŸ¬ ê°œì˜ Process ì§€ì›, ê·¸ì•ˆì— ì—¬ëŸ¬ê°œ Threadë“¤ì„ ì§€ì›



#### ì™œ Multithreadingì„ í•´ì•¼ë˜ë‚˜?

- Concurrencyë¥¼ ì‰½ê²Œ ëŠ˜ë¦¬ê³  response timeì„ ì¢‹ê²Œ ë§Œë“¤ì–´ ì£¼ê¸° ë•Œë¬¸ì— 
  - Multithreadingì„ ì‚¬ìš©í•˜ê²Œ ë˜ë©´ ì™œ ë³‘ë ¬í”„ë¡œê·¸ë˜ë°í•  ë•Œ overheadê°€ ì ì€ ì´ìœ  : processëŠ” 1ê°œë§Œ ë‚˜ë‘ê³  Threadë§Œ ì—¬ëŸ¬ê°œ ìƒì„±í•˜ë©´ ë˜ê¸° ë•Œë¬¸ì—. ì´ë ‡ê²Œ ë˜ë©´ ë©”ëª¨ë¦¬ ìš”êµ¬ëŸ‰ë„ ì¤„ì–´ë“¤ê³  ì„±ëŠ¥ë„ ê°œì„ ì´ ë¨ 
- Threadë“¤ì´ processì— í• ë‹¹ëœ Resourceë¥¼ ê³µìœ  ê°€ëŠ¥í•˜ë‹¤
  - ë¬¼ë¡  ê³µìœ ëœ Resourceë¥¼ ê°€ì§€ê²Œë˜ë©´ Synchronization ë¬¸ì œê°€ ë°œìƒí•¨
- êµ¬í˜„ì´ ì‰½ê³  ê²½ì œì ì´ë‹¤
  - ìƒˆë¡œìš´ Threadë¥¼ ìƒì„±í•  ë•Œë„ ì‹œê°„ë„ ì ê²Œ ê±¸ë¦¬ê³  ë©”ëª¨ë¦¬ë„ ì¡°ê¸ˆ ì°¨ì§€í•¨
  - Process context switching ë³´ë‹¤ Thread context switchingì´ ë” ê²½ì œì ì¸ ë™ì‘ì„ 



#### Multithreading êµ¬í˜„ ë°©ë²•

1. **User-Level êµ¬í˜„** : Kernelì´ ì „í˜€ ëª¨ë¥´ê²Œ êµ¬í˜„í•˜ëŠ” ë°©ë²•

   - ê¸°ë³¸ì ì¸ Idea : OSëŠ” <a href="#CUP">Conventional UNIX Process</a> ë§Œ ì§€ì›í•¨. ê·¸ ì•ˆì— Multithreadingì„ êµ¬í˜„. ëŒ€ì‹  Kernelì€ ê³ ì¹˜ì§„ ì•Šê³  User-levelì—ì„œ.

   - êµ¬í˜„ ë°©ì•ˆ :

     1. Threadë¥¼ ì—¬ëŸ¬ ê°œ ë„£ì„ë ¤ë©´ ì—¬ëŸ¬ ê°œ Stack ì„ êµ¬í˜„ 

     2. ê° Threadì˜ Thread Control Blockë¥¼ ë§Œë“¤ì–´ì„œ User-levelì— ìˆì–´ì•¼ë¨
     3. Thread ê°„ì˜ switchingì„ ìœ„í•´ User-levelì— Schdulerê°€ ìˆì–´ì•¼ë¨ ğŸ’ğŸ» í•¨ìˆ˜ë¡œ êµ¬í˜„í•˜ê³  ê·¸ í•¨ìˆ˜ë“¤ì„ ë¬¶ì–´ì„œ Libraryë¡œ ë§Œë“¤ë©´ë¨

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-02 at 1.01.50 PM.png" alt="Screen Shot 2021-09-02 at 1.01.50 PM" style="zoom:47%;" /> 

   - Thread : 

     - 100% User-level Entity
     -  Kernelì€ Threadë“¤ì´ ì¡´ì¬í•˜ëŠ”ì§€ ëª¨ë¦„

   - Thread Library : 

     - Threadë¥¼ ìƒì„±í•˜ê³  ì†Œë©¸ì‹œí‚¤ëŠ” code í¬í•¨í•¨ 
     - Thread contextë¥¼ ì €ì¥í•˜ëŠ” code í¬í•¨í•¨
     - Threadë“¤ ê°„ì— Communicatoinì„ ì œê³µí•´ì£¼ëŠ” í•¨ìˆ˜ë“¤ì„ í¬í•¨í•¨

   - ë‹¨ì  :

     1. OSê°€ Threadì—ê²Œ ì§ì ‘ Interruptë¥¼ ì „ë‹¬ í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— <a href="#Preemptive">Preemptive Scheduling</a>ì—ëŠ” í•œê³„ê°€ ìˆìŒ

        ***Example.*** User-level Threadê°€ `read()` System callì´ í•„ìš”í–ˆë‹¤. ê·¸ëŸ¼ DMAê°€ Disk I/Oê°€ ëë‚˜ê³  Interruptë¥¼ ë‹¤ì‹œ CPUí•œí…Œ ê±¸ë•Œ ê·¸ Interruptê°€ Threadì—ê²Œ ì „ë‹¬ ë  ìˆ˜ ìˆëŠ” ë°©ë²•ì´ ì—†ìŒ

     2. í•œ Threadê°€ System callì„ í˜¸ì¶œí•˜ëŠ” ê²½ìš° í•´ë‹¹ Processì˜ ëª¨ë“  Threadê°€ Block ë¨

        ***Example.*** ì–´ë–¤ Threadê°€ ìˆ˜í–‰í•˜ë‹¤ê°€ `read()` System callì„ í˜¸ì¶œí•¨. ê·¸ë˜ì„œ Kernelì´ Disk I/Oë¥¼ ì‹œì‘í•˜ê²Œ ë˜ë©´ Disk I/O ë™ì‘ì´ ëë‚  ë•Œ ê¹Œì§€ Threadê°€ ì†í•œ Processë¥¼ Blocking ì‹œí‚´. ì‹¤ì œë¡œ ê·¸ Processì•ˆì—ëŠ”  `read()` ë¥¼ í˜¸ì¶œí•œ Thread ë¿ë§Œ ì•„ë‹ˆë¼ ë‹¤ë¥¸ Threadë“¤ì´ ì”ëœ© ìˆì„ ìˆ˜ ìˆìŒ. ì¦‰, ì›ë˜ ë‹¤ë¥¸ Threadë“¤ì´ ìˆ˜í–‰ì„ í•  ìˆ˜ ìˆìŒì—ë„ ë¶ˆêµ¬í•˜ê³  ìˆ˜í–‰ì„ ì§„ì „ì‹œí‚¤ì§€ ëª»í•˜ëŠ” ë¬¸ì œê°€ ìƒê¹€ 

   - ì¥ì  :

     1. êµ¬í˜„ì´ ì‰¬ì›€
     2. OS codeë¥¼ ê³ ì¹˜ì§€ ì•Šê³ ë„ Multithreadingë¥¼ í•  ìˆ˜ ìˆìŒ
     3. ë³‘ë ¬ ì—°ì‚°ì— ê° Threadê°€ mappingë˜ì–´ ì˜ ë™ì‘ë¨

   - User-Level êµ¬í˜„ì´ ìœ ìš©í•œ ê³³

     - ë³‘ë ¬ ì—°ì‚° system

2. **Kernel-Level êµ¬í˜„** : Kernelì´ 100% ì•Œê³  ì§€ì›í•˜ëŠ” ë°©ë²•

     <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-02 at 1.02.46 PM.png" alt="Screen Shot 2021-09-02 at 1.02.46 PM" style="zoom:47%;" />

   - ê¸°ë³¸ì ì¸ Idea : 
     - Thread creation, terminationì´ ëª¨ë‘ Kernel í•¨ìˆ˜ System callë¡œ êµ¬í˜„ë¨. 
     - Thread Control Blockë„ ì—­ì‹œ Kernelì´ ì¡°ì‘í•¨. 
     - Kernelì´ ì§ì ‘ Threadë“¤ì„ ë‹¤ Schdulingí•˜ëŠ” Schduling entityë“¤ì´ ëœë‹¤ 
   - Windowë„ Kernel-Level threadë¥¼ ì§€ì›í•¨ 
   - ì¥ì  :
     1. User-Level êµ¬í˜„ì˜ ë‹¨ì ë“¤ì„ ë‹¤ í•´ê²° í•  ìˆ˜ ìˆë‹¤
   - ë‹¨ì  :
     1. Kernel ë‹¨ì˜ ìˆ˜í–‰ì‹œê°„ì´ ì¦ê°€í•˜ë©´ì„œ ì¶”ê°€ì ì¸ overheadê°€ ë°œìƒí•¨
   - Kernel-Level êµ¬í˜„ì´ ìœ ìš©í•œ ê³³
     - Reactive control system

3. **Combined User-Level / Kernel-Level êµ¬í˜„**

     <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/Screen Shot 2021-09-02 at 1.03.21 PM.png" alt="Screen Shot 2021-09-02 at 1.03.21 PM" style="zoom:47%;" />

   - ìƒë‹¹íˆ ë§ì€ ë¶€ë¶„ì„ User-Level Threadê°€ ì²˜ë¦¬í•¨
   - Threadê°€ <a href="#Preemptive">Preemptive Scheduling</a>ì„ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” ê¸°ë²•ì„ User-Levelì— ì¶”ê°€í•œ ê²ƒì´ Combined User-Level / Kernel-Level Thread êµ¬í˜„
   - ì¶”ê°€ëœ ê¸°ë²•
     - Interruptê°€ ì™”ì„ ë•Œ, ê·¸ Interruptë¥¼ User-Level Thread Schdulerì—ê²Œ forwardí•´ì„œ ì–´ë–¤ Thread ê¹¨ì–´ë‚˜ì•¼ë˜ëŠ” ì•Œë ¤ì£¼ëŠ” ê¸°ë²• 
   - Sun Microsystems Solaris :
     - User-level Threadì™€ Kernel-level Thread ì—°ê²°ì‹œì¼œì„œ ê´€ë¦¬í•¨



#### ì‘ìš©í”„ë¡œê·¸ë˜ë¨¸ë¡œì¨ Thread programming modelì„ ì–´ë–»ê²Œ ì‚¬ìš©í•  ê²ƒ ì¸ê°€?

- ì‘ìš©í”„ë¡œê·¸ë˜ë¨¸ë¡œì¨ Thread programming modelì„ ì–´ë–»ê²Œ ì‚¬ìš©í•  ê²ƒ ì¸ê°€?
  - Multi-threadingì´ ì œê³µí•´ì£¼ëŠ” APIë¥¼ ì•Œì•„ì•¼ë¨

- Portable Operating System Interface (POSIX) : 

  - ë‹¤ì–‘í•œ UNIX ê³„ì—´ OSë“¤ì˜ API í‘œì¤€í™” í•˜ê¸° ìœ„í•´ IEEEê°€ ì •ì˜í•œ interface

  | Pthreads API          | Description                                                  |
  | --------------------- | ------------------------------------------------------------ |
  | `pthread_create(...)` | - ìƒˆë¡œìš´ thread ìƒì„±<br/>- í•¨ìˆ˜ì˜ function pointerê°€ argumentë¡œ ë“¤ì–´ê° |
  | `pthread_exit()`      | - í˜¸ì¶œí•˜ëŠ” threadë¥¼ terminateì‹œí‚´                            |
  | `pthread_join(...)`   | - argumentë¡œ ë“¤ì–´ì˜¨ threadê°€ terminateí•  ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¼      |
  | `pthread_yield()`     | - Non-preemptive Scheduling ë•Œ CPUë¥¼ ë„˜ê²¨ì¤„ë•Œ ì‚¬ìš©           |

- Thread life cycle 

    <img src="/assets/images/æ“ä½œç³»ç»Ÿ/pic02/life cycle_waifu2x_photo_noise3_scale_tta_1.png" alt="life cycle_waifu2x_photo_noise3_scale_tta_1" style="zoom:33%;" />

  - Main thread : Processì—ëŠ” defaultë¡œ í•œê°œì˜ threadë¥¼ ê°€ì§€ê³  ìˆìŒ

  â“`pthread_yield()` ë¥¼ í˜¸ì¶œí•œ ThreadëŠ” ì–´ë–¤ ì‹ìœ¼ë¡œ ìˆ˜í–‰ì´ ì¬ê°œë˜ëŠ”ì§€?

  â€‹	ğŸ’ğŸ» `pthread_yield()` ì— ì˜í•œ Threadì˜ ìƒíƒœ ë³€í™”ëŠ” OSì— ì˜í•´ ê´€ë¦¬ëœë‹¤. User code ìƒì—ì„œëŠ” `pthread_yield()` ì˜ í˜¸ì¶œ ì§€ì ì—ì„œ ì •ì§€ë˜ëŠ” ê²ƒìœ¼ë¡œ ë³´ì´ë©°, Threadê°€ ë‹¤ì‹œ CPUë¥¼ í• ë‹¹ ë°›ìœ¼ë©´ ë‹¤ìŒ Statement ë¶€í„° ìˆ˜í–‰ì„ ì¬ê°œí•œë‹¤

- Example Code

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <assert.h>
  #include <pthread.h>
  #include <unistd.h>
  
  #define NUM_THREADS 5
  
  // mainì—ì„œ pthread_create()ì˜ argumentë¡œ ë“¤ì–´ê°ˆ function pointer
  void *perform_work(void *arguments){
    int threadID = *((int *)arguments);
    printf("Hello World! I'm thead number %d\n", threadID);
    return null;
  }
  
  int main(void) {
    pthread_t threads[NUM_THREADS];
    int thread_args[NUM_THREADS];
    int i, result;
    
    //pthread_create()ë¥¼ í†µí•´ í•˜ë‚˜ì”© threadë¥¼ ìƒì„±í•˜ëŠ” ë¶€ë¶„
    for (i = 0; i < NUM_THREADS; i++) {
      printf("IN MAIN: Creating thread %d.\n", i);
      thread_args[i] = i;
      result = pthread_create(&threads[i], NULL, perform_work,(void*) &thread_args[i]);
      assert(0 == result);
    }
  
    printf("IN MAIN: All threads are created.\n");
  
    //pthread_join()ì„ í†µí•´ ê° threadë“¤ì´ ì™„ì„±ë ë•Œ ê¹Œì§€ ê¸°ë‹¤ë¦¬ëŠ” ë¶€ë¶„
    for (i = 0; i < NUM_THREADS; i++) {
      result = pthread_join(threads[i], NULL);
      assert(0 == result);
      printf("IN MAIN: Thread %d has ended.\n", i);
    }
  
    printf("MAIN program has ended.\n");
    return 0;
  }
  ```

  

