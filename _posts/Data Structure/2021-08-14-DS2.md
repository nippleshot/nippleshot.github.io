---
layout: article
title: Tree(Heap, BST, Balanced BST), Union-Find 
author: J_宋
tags: DataStructure 한글
mathjax: true
key: dataStructure02
---



#### Tree

- In a **full binary tree** all nodes have either 0 or 2 children.
- In a **complete binary tree** all levels except the last are completely filled, and in the last level all nodes are to the left as much as possible. 
  - 즉 complete binary tree 이면 balanced tree

##### Heap

- Binary Tree :arrow_right: 배열, 리스트
- **Heap의 성질** : 모든 부모 node의 key 값은 자식 node의 key 값보다 작지 않다
- 여러 개의 값들 중에서 **최댓값이나 최솟값을 빠르게 찾아내도록** 만들어진 자료구조이다.
- **Search가 필요할 때는 Heap 사용 :x:**
- **가장 크거나 작은 값을 찾거나 지우고 싶을 경우 Heap 사용**
- n개 node : Heap의 높이

- Heap에서의 부모 노드와 자식 노드의 관계

  - 왼쪽 자식 index = (부모 index) * 2
  - 오른쪽 자식 index = (부모 index) * 2 + 1
  - 부모 index = (자식의 index) / 2
     <img src="/assets/images/DataStructure/myNote/pic02/heap-index-parent-child.png" alt="heap-index-parent-child" style="zoom:38%;" />

- Heap에서 제공하는 연산 :

  - Insert

     <img src="/assets/images/DataStructure/myNote/pic02/maxheap-insertion.png" alt="maxheap-insertion" style="zoom:28%;" />

  - findMax

    root node를 return 하면 됨

  - deleteMax

    1. 마지막 Leaf node를 root node로 올린다

    2. root node 부터 child node 하나하나 비교하면서 Heap의 성질을 만족하지 못하면 swap 하면서 전체 heap tree를 수정한다  

  - search :x:

  

##### Binary Tree

- 각 node의 자식 Node가 0~2개까지 있는 tree

- Binary Tree의 각 Node들은 left, right, parent가 있음

  - 즉 root node의 경우 parent가 null이 됨

  ```python
  class Node:
    def __init__(self, data):
      self.data = data
      self.parent = None
      self.left = None
      self.right = None
      
    def __str__(self):
      return str(self.data)
  ```



- Traversal (순회)

  - Preorder : M-L-R

    ```python
    def preorder(self):
      if self != None:
        print(self.data)
        if self.left:
          self.left.preorder()
        if self.right:
          self.right.preorder()
    ```

  - Inorder : L-M-R

    ```python
    def inorder(self):
      if self != None:
        if self.left:
          self.left.inorder()
        print(self.data)
        if self.right:
          self.right.inorder()
    ```

  - Postorder : L-R-M

    ```python
    def postorder(self):
      if self != None:
        if self.left:
          self.left.postorder()
        if self.right:
          self.right.postorder()
        print(self.data)
    ```

    

##### Binary Search Tree (BST)

- Search하기 좋은 Binary tree 

  - time complexity : O(tree height)

  ```python
  class BST:
    def __init__(self):
      self.root = None
      self.size = 0
  ```

- BST 성질 : 각 node의

  - Left subtree의 data값은 node의 data값보다 작거나 같아야함
  - Right subtree의 data값은 node의 data값보다 커야함

- 제공 연산들

  - Find location : : O(tree height)

    - data 값 node가 있다면 해당 node return함, 없다면 node가 삽입될 부모 node return함

    ```python
    def find_loc(self, data):
      if self.size == 0:
        return None
      parent = None
      compareNode = self.root
      while compareNode != None:
        if compareNode.data == data:
          # data 값 node가 BST에 있을 경우
          return compareNode
        elif compareNode.data < data:
          parent = compareNode
          compareNode = compareNode.right
        else:
          parent = compareNode
          compareNode = compareNode.left
      # data 값 node가 BST에 없을 경우
      return parent    
    ```

  - Insert : O(tree height)

    ```python
    def insert(self, data):
      parent = self.find_loc(data)
      if p == None or p.data != data:
        newNode = Node(data)
        if p == None: # BST가 empty인 경우
        	self.root = newNode
        else: # BST가 empty가 아니고 들어갈 위치의 parent의 data와 새로입력하는 data가 다른 경우
          newNode.parent = parent
          if parent.data >= data:
            parent.left = newNode
          else:
            parent.right = newNode
        self.size += 1
        return newNode
      else:
        print("data is already in BST")
        return parent
    ```

  - Delete : O(tree height)



##### Balanced Binary Search Tree (Balanced BST)

- BST 성질을 만족하면서 BST의 높이가 <img src="/assets/images/DataStructure/myNote/pic01/21-55screenshot.png" alt="21-55screenshot" style="zoom:83%;" />에 비례될 수 있게 유지 될 수 있음

- *Rotation operation* : tree의 일부를 회전시켜서 전체 tree 높이를 줄임 <img src="/assets/images/DataStructure/myNote/gif/rotation.gif" alt="rotation" style="zoom:53%;" />

   <img src="/assets/images/DataStructure/myNote/pic02/13-34screenshot.png" alt="13-34screenshot" style="zoom:60%;" />

  - z node 를 기준으로 right rotation 이후  수정해야되는 Link들
    1. 원래 z's parent node.right 를 z :arrow_right: x
    2. x node.parent 를 z :arrow_right: 원래 z's parent node
    3. x node.right를 b :arrow_right: z
    4. z node.parent를 원래 z's parent node :arrow_right: x
    5. z node.left를 x :arrow_right: b
    6. b node.parent를 x :arrow_right: z
  
- ***AVL Tree***

  - 모든 node에 대해서 node의 left subtree와 right subtree의 높이 차가 1 이하인 BST

    ```python
    # extends BST
    class AVL(BST): 
      def insert(self, data):
      	newNode = super(AVL, self).insert(data) # BST.insert를 호출
        x,y,z = find() 
        # z : 처음으로 AVL tree 조건이 깨진 node
        # y : z node 바로 아래 자식 node
        # x : y node 바로 아래 자식 node
        w = rebalance(x,y,z)
        if w.parent == None:
          self.root = w
    ```

     *insert* : 많아 봤자 2회 rotation으로 AVL 조건을 성립할 수 있음 

    - Time complexity : O(log n)

     <img src="/assets/images/DataStructure/myNote/pic02/13-49screenshot.png" alt="13-49screenshot" style="zoom:93%;" />

    - node x,y,z 가 일직선형의 모형일 경우 : 
      1. node y 기준으로 rotate right
    - node x,y,z 가 삼각형의 모형을 나타 낼 경우 : 
      1. node y 기준으로 rotate left
      2. rotate 이후 tree에서 node z 기준으로 rotate right

    *delete* :

     <img src="/assets/images/DataStructure/myNote/pic02/0-1screenshot.png" alt="0-1screenshot" style="zoom:87%;" />

    - y node가 root가 되는 subtree는 균형이 맞춰졌지만 w node가 root가 되는 전체 tree를 봤을 땐 AVL 조건을 성립하지 못함
    - 즉, BST가 복잡할 경우 Insert 처럼 한 두번만 rotation해서 AVL 조건을 성립하지 못함
      - Delete의 time complexity : O(log n)

- ***Red-Black***

  - Red-Black 조건

    1. 모든 node는 red/black

    2. Root node는 black

    3. leaf node는 black

    4. red node는 두개의 자식 node를 갇는데 모두 black이여야 됨

    5. 각 node에서 leaf node로 가는 경로들 중 black node의 수가 항상 같아야됨

       

##### B-Tree

- **모든 리프노드들이 같은 레벨을 가질 수 있도록** 자동으로 벨런스를 맞추는 트리
- M차 B-tree : 하나의 Node에 최대 M 개의 data가 들어올 수 있음
  - M이 짝수냐 홀수에 따라 알고리즘이 다름
- 규칙 :
  - node의 data 수가 N개라면 자식 node의 data 수는 N+1개 여야된다
  - 각 node의 data는 정렬된 상태여야된다
  - node의 data D의 왼쪽 subtree는 D보다 작은 값들이고, 오른쪽 subtree는 D보다 큰 값들이여야 된다
  - root node를 제외한 모든 node들은 적어도 M/2개의 data를 가지고 있어야 된다 
  - 외부 node는 모두 같은 level에 있다
  - 입력자료는 중복될 수 없다
- 参考 ： <a href="https://velog.io/@emplam27/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-B-Tree">Blog</a>



#### Union-Find (Disjoint Set)

- 공통 원소가 없는, 즉 "상호 배타적" 인 부분 집합 들로 나눠진 원소들에 대한 정보를 저장하고 조작하는 자료구조

- tree형 으로 `Union-Find` 를 구현하면 배열보다 빠르게 **Union** 연산을 수행할 수 있슴

  - **루트 노드** 가 존재 하므로, 각 원소가 속하는 집합 번호를 바로 이 **루트 노드**의 원소로 정함

      <img src="/assets/images/DataStructure/myNote/pic02/unionFind.png" alt="unionFind" style="zoom:75%;" />

    ```python
    class Node:
      def __init__(self, data):
        self.data = data
        self.parent = self
        self.rank = 0 # height를 의미함
    	
      def make_set(x):
        return Node(x)
      
      def find
    ```

    

  - **Union** 연산

      <img src="/assets/images/DataStructure/myNote/pic02/union.png" alt="union" style="zoom:75%;" />

    ``` python
    def union(x,y):
    	setA = find(x) // x가 들어 있는 set tree 찾기
    	setB = find(y) // y가 들어 있는 set tree 찾기
    	if setA != setB: 
    		// 가능하면 height가 높은 tree에 작은 tree를 붙이는게 최종적으로 낮은 height를 유지하기 좋음 
    		if setA.rank > setB.rank:
    			setB.parent = setA
    		else if setA.rank < setB.rank:
    			setA.parent = setB
    		else: 
          // setA.rank == setB.rank 일 경우 어느 쪽에다 연결해도 no problem
    			setA.parent = setB
    			setB.rank += 1
    ```



#### Conclusion 

 <img src="/assets/images/DataStructure/myNote/pic01/Screen Shot 2021-08-28 at 11.12.14 AM.png" alt="Screen Shot 2021-08-28 at 11.12.14 AM" style="zoom:30%;" />



***

《Reference》

1. <a href="https://www.youtube.com/watch?v=M2mcJvmYpWY&list=PLsMufJgu5933ZkBCHS7bQTx0bncjwi4PK&index=2">Youtube</a>



***

